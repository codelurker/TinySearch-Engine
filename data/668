http://www.cs.dartmouth.edu/~cs5/exams/final-review.html
3
<html> <head><title>CS 5 Spring 2008 Review for Final Exam</title></head><body><h1><a href="/~cs5/">CS 5 Spring 2008</a><br>Review for Final Exam</h1><h2>Ground Rules</h2>The final exam will be on Friday, May 30, 3:00-6:00 PM, in Kememy 008.<p>I expect the exam to be about the same length as the other two exams.The registrar mandates that the exam be limited to three hours.<p>As usual, you may bring a <strong>crib sheet</strong> to the exam,subject to the following restrictions.  The crib sheet must be asingle sheet of paper, 8 1/2" x 11" at the largest.  You may write onboth sides of the sheet.  You may write whatever you like.  Buteverything on the sheet must be written by you, by hand or in 11-pointor larger type.  Photocopying is specifically disallowed.  <p>As on Exam 2, we will give you documentation on the classes that youneed to use on the exam, with all relevant methods listed.<h2>Review Session</h2>There will be an open review session on Thursday, May 29,2:00-4:00 PM, in Kemeny 008.  Attendance is completely at your option.Come for as much or as little of it as you like.<h2>Office Hours</h2>I will hold office hours as usual Monday-Wednesday of this week. I will also be available 1-2 on Thursday and after the review session. <h2>Results</h2>Since we won't be able to return the final exam in class, I willannounce via a Blitz to the entire class when the final exams havebeen graded. You may then come by to pick up your exam or can reply to find out yourfinal exam grade. I will keep the examsuntil the end of the Spring 2009 term, so if you're going to be awayfrom campus until then, you have the option of picking up your examwhen you return.  The registrar makes course grades available after you have filled out the course evaluation, which I hope that you will do.<h2>Material</h2>For the final exam, you are responsible for all material covered inthe lectures, short assignments, and homeworks.  This includes thesolution to SA 17, which you are not required to do but should understand.You should lookthrough all the lecture notes on the web, class examples, andassignment solutions.  Solutions to Homework #5 will be posted justafter the review session ends on December 3.  Make sure that you understandall the material from the course.  There should be no doubt in yourmind about any of the programs given in class or any of the assignmentsolutions.<p>The final exam will focus on the topics covered since the second exam:recursion, Swing, searching, sorting, big-O and big-&Theta; notation, linked lists, iterators, Lists, Sets, and Maps.  The final exam will not be exclusively on these topics,however.  There will be material from earlier parts of the course, butsuch material will relate to the above topics.  For example, youshould be able to sort an array of objects, or of references toobjects, given an appropriate method for comparing two objects.<p>I do not expect you to have memorized the Java code for any of thesorting methods.  You should understand how each of these methodsworks, however, and you should also know the worst-case, average-case,and best-case running times (using asymptotic notation) of each.  I doexpect you to know how to traverse, insert into, remove from, andsearch linked lists in both forms we examined: circular, doubly linkedwith a sentinel, and singly linked.<h2>Sample Questions</h2>I have asked questions similar to the following in previous exams.<em>These are sample questions and do not represent a full practiceexam.</em>  You can find a additional questions from past exams at <a href="PracticeFinalExamQues.doc">PracticeFinalExamQues.doc</a> and the solutionto those problems at <a href="PracticeFinalExamSol.doc">PracticeFinalExamSol.doc</a>. However, questions 1e and 2a cover topics that we did not cover in this course (exceptions and cloning).<ol>  <li> Suppose you are designing a GUI using Swing.  One part of       the GUI has 2 radio buttons, labeled <code>AM</code> and       <code>FM</code>; exactly one of       these buttons is to be selected at all times.  Another part       of the GUI has 4 radio buttons, labeled <code>Country</code>,       <code>Rock</code>, <code>Classical</code>, and <code>Talk Radio</code>;       exactly one of these buttons is to be selected at all times.       How do you specify, using Swing methods, these button groupings       and that one button in each is selected at all times?       <p>  <li> The following statement is intended to determine whether       <code>p</code> references the next-to-last element of a       singly linked list:       <xmp>       boolean isNextToLast = (p.next.next == null);       </xmp>       The singly linked list is like we saw in class: the <code>next</code>       instance variable of the last element has the value <code>null</code>       (and no other <code>next</code> value is <code>null</code>).       This statement compiles without error, but something is wrong       with it.  What is wrong?  Assume that <code>next</code>       is the usual link information in an element of a linked list.              <p>       Also, fix the problem by writing a code fragment that does the       job correctly.  You may assume that <code>p</code> is not       <code>null</code>.       <p>  <li> For each of the following statements, state whether you agree       or disagree, and explain your answer.       <ol type="a">	 <li> Merge sort runs in <i>O</i>(<i>n</i><sup>2</sup>) time.	 <li> Insertion sort runs in <i>O</i>(<i>n</i><sup>2</sup>) time.	 <li> In the worst case, insertion sort runs in	      &Theta;(<i>n</i><sup>2</sup>) time.	 <li> In the best case, insertion sort runs in	      &Theta;(<i>n</i><sup>2</sup>) time.	 <li> Quicksort's average-case running time is &Theta;(<i>n</i>	      lg <i>n</i>).       </ol>       <p>  <li> Recall the Josephus problem from the homework.  <i>n</i>       soldiers, numbered 1 to <i>n</i>, stand in a circle, and       every <i>k</i>th soldier still alive is killed, starting with       soldier number <i>k</i>.  The goal is to print out the order       in which soldiers die.       <p>       You solved the Josephus problem using a circular, doubly       linked list.  In fact, you could have solved it with an array       of <i>n</i> <code>boolean</code>s, where each entry indicates whether       a soldier is alive.  Initially, all <i>n</i> entries are       <code>true</code>.  Then you       go through the array, printing out every <i>k</i>th       <strong>remaining</strong> living soldier and setting its entry       to <code>false</code>.  Whenever you reach the end of the       array, you wrap around to the beginning.       <p>       Write a method with the header       <xmp>       public static void Josephus(int n, int k)       </xmp>       that prints out the order in which soldiers are killed, using       an array as described above.  You will need to dynamically       allocate the array with <i>n</i> entries.  You may assume that       <code>k >= 1</code> and <code>k <= n</code>.       <p>       As a reminder of how the output should look (you should simulate       your method by hand to check it), the call       <code>Josephus(5, 2)</code> should produce the following output:       <xmp>       Soldier 2 buys the farm.       Soldier 4 buys the farm.       Soldier 1 buys the farm.       Soldier 5 buys the farm.       Soldier 3 buys the farm.       </xmp>       <p>  <li> Professor B. O. Zo's program has class <code>RectList</code>,       which is a circular, doubly linked list       of rectangles with a sentinel, and she needs to write a function       that draws all the rectangles in the list that intersect a       given rectangle.       <p>       Here are the declarations of the instance variables of the       <code>Rect</code> class, which are just like those we saw       in lecture:       <xmp>public class Rect{  private int myX, myY;          // x and y coords of upper left  private int myWidth, myHeight; // Rect's width and height, in pixels  private Color myColor;         // Rect's color  // Methods go here.  Here are two in particular:         public boolean intersects(Rect r)  {    // You fill this in.  }  public void draw(Graphics page)  {    page.setColor(myColor);    page.drawRect(myX, myY, myWidth, myHeight);  }}       </xmp>              <ol>	 <li> Let us add to the <code>Rect</code> class a method with	      the following header:	      <xmp>public boolean intersects(Rect r)	      </xmp>	      This method returns <code>true</code> if the	      <code>Rect</code> it is invoked on and the <code>Rect r</code>	      intersect.  Otherwise, it returns <code>false</code>.	      <p>	      	      Two rectangles intersect if and only if they overlap in	      both dimensions.  Two rectangles overlap in the	      horizontal dimension if the left value of each is no	      greater than the right value of the other.  Two	      rectangles overlap in the vertical dimension if the top	      value of each is no greater than the bottom value of the	      other.	      <p>	      Write the body of the <code>intersects</code> method.	      For full credit, your implementation should consist of	      only straight-line code (no if statements, no switch	      statements, and no loops).       </ol>             <p>       Here is some of the code of the <code>RectList</code> class and       its private inner class <code>Element</code>.  Note that Professor       Zo has specialized the <code>Element</code> class to have its       instance variable <code>theRect</code> be a reference to a       <code>Rect</code>, rather than a reference to a generic       <code>Object</code>.         <xmp>public class RectList{  // Instance variables  private Element current;          // current position in the list  private Element sentinel;         // sentinel, serves as head and tail    // A private class representing the elements in the list  private class Element  {    public Rect theRect;            // reference to Rect stored in this element    public Element next;            // reference to next item in list    public Element previous;        // reference to previous item in list        // Constructor for a linked list element, given an object.    public Element(Rect r)    {      next = previous = null;       // no element before or after this one, yet      theRect = r;                     }  }  // Constructor for a doubly linked list, initially empty.  public RectList()  {    // Allocate the sentinel with a null reference.    sentinel = new Element(null);      // Make the list be empty by having the sentinel point to itself    // in both directions.    sentinel.next = sentinel.previous = sentinel;      // There's only one place to put the current reference...    current = sentinel;  }  // Insert a new element with given Rect, after the current position.  // (If current == sentinel, the new element becomes the new head.)  // Make the new element the current position.  public void insert(Rect r)  {    Element x = new Element(r);         // allocate a new element    // Splice in the new element.    x.next = current.next;    x.previous = current;    current.next.previous = x;    current.next = x;    current = x;                        // new element is current position  }  // Draw all rectangles that intersect a given Rect.  public void drawIntersecting(Rect r, Graphics page)  {    // You fill this in.  }}               </xmp><ol>  <li value=2> Write the body of the method <code>drawIntersecting</code>,  which has each rectangle in the linked list draw itself if it  intersects the rectangle that <code>r</code> references.  Rectangles  on the linked list that do not intersect <code>r</code> should be  ignored.  Make appropriate calls to the <code>intersects</code> method  of <code>Element</code> to determine whether rectangles intersect,  and make appropriate calls to the <code>draw</code> method of  <code>Rect</code> to draw rectangles.  Assume that no iterator  class for the <code>RectList</code> class is available for your use.</ol><p>  <li> Professors Morris (Moe) Howard, Lawrence (Larry) Fine, and       Jerome (Curley) Howard of the Brighto Institute of Technology (B.I.T.)       have proposed a very elegant sorting method, which has been named       <em>Stooge Sort</em> in their honor.  It is a recursive method that       works by sorting a subarray <code>a[p..r]</code>.  As with merge sort,       the initial call to sort <i>n</i> elements would be for the       subarray <code>a[0..n-1]</code>.  It goes as follows.       <p>       The base cases occur when the subarray has only two elements or       fewer.  If the subarray has zero or one element, it is already sorted,       and so nothing else need be done.  If the subarray has exactly two       elements, then they are compared to each other and, if they are not in       sorted order, they are swapped.       <p>       The recursive case occurs when the subarray has <i>k</i> elements,       where <i>k</i> &#x2265; 3.  We divide the subarray into thirds:       the first       <i>k</i>/3 elements, the middle <i>k</i>/3 elements, and the last       <i>k</i>/3 elements.  If 3 does not exactly divide <i>k</i>, then       there are one or two elements left over, and these leftover elements       are <em>always</em> put into the middle third.  After       determining the indices that demarcate these subarrays, Stooge       Sort recurses to sort three subarrays in order:       <p>       <ol>	 <li> The first two-thirds (i.e., the subarray consisting of	      the first and middle thirds).	      <p>	 <li> The last two-thirds (i.e., the subarray consisting of	      the middle and last thirds).	      <p>	 <li> The first two-thirds again.	      <p>       </ol>       Note that each of the three recursive steps consists of <em>just       one</em> recursive call, which is made on a subarray of two-thirds of       the elements in <code>a[p..r]</code>.  For example, if the subarray is       <code>a[0..10]</code>, with <i>k</i> = 11 elements, the first third is       <code>a[0..2]</code>, the middle third is <code>a[3..7]</code>, the       last third is <code>a[8..10]</code> (note how the two leftover       elements are put into the middle third), and so we recursively sort       <code>a[0..7]</code>, <code>a[3..10]</code>, and <code>a[0..7]</code>.       <p>       (You might wonder how the Stooge Sort method can possibly work.       Although you do not need to understand it to solve this problem,       the proof of Stooge Sort's correctness is quite simple.  Consider any       value among the <i>k</i>/3 largest.  Where is it after the first       recursive call?  Either it started out in the last <i>k</i>/3       positions, in which case this call did not touch it, or it started out       in the first 2<i>k</i>/3 positions and was put by the first recursive       call somewhere in the middle <i>k</i>/3 positions.  Either way, it is       somewhere in the last 2<i>k</i>/3 positions.  Where is it after the       second recursive call?  It must be in the last <i>k</i>/3 positions,       and these last <i>k</i>/3 positions must be sorted, too.  So the       <i>k</i>/3 largest values are in their correct places after the second       recursive call.  All that remains is to sort the 2<i>k</i>/3 smallest       values, and the third recursive call handles that.)       <p>       <ol>	 <li> Assuming that the array <code>a</code> holds	      <code>int</code>s, write a method with the header	      <xmp>public static void StoogeSort(int [] a, int p, int r)	      </xmp>	      that sorts the subarray <code>a[p..r]</code>.  Make sure	      that your method follows the above description above	      of the Stooge Sort method.  In particular, make sure	      that you get the base cases right, that you compute the	      subarrays correctly (with any leftover elements going	      into the middle third), and that you make the three	      recursive calls correctly.	      <p>	      	      You may assume that you are provided the following	      function that swaps two integers:	      <xmp>public static void swap(int [] a, int i, int j){  int t = a[i];  a[i] = a[j];  a[j] = t;}	      </xmp>	      You may call this <code>swap</code> method as needed.	      <p>	 <li> Using techniques that you will learn in later computer	      science courses (should you choose to continue in	      computer science), you can easily show that the running	      time of Stooge Sort to sort <i>n</i> values is	      &Theta;(<i>n</i><sup>log<sub>3/2</sub> 3</sup>).  For	      your information, log<sub>3/2</sub> 3 is between 2.709	      and 2.710.	      <p>	      Given this Stooge Sort running time, and given the	      running times of other sorting methods that you know,	      discuss whether or not you think Professors Howard,	      Fine, and Howard deserve tenure.	      <p>	             </ol></ol><hr><address><a href="http://www.cs.dartmouth.edu/~scot/">Scot Drysdale</a></address><!-- hhmts start -->Last modified: Sat May 24 2004<!-- hhmts end --></body> </html>